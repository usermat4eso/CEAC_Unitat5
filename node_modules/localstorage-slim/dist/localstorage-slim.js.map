{"version":3,"sources":["webpack://ls/webpack/universalModuleDefinition","webpack://ls/webpack/bootstrap","webpack://ls/webpack/runtime/define property getters","webpack://ls/webpack/runtime/hasOwnProperty shorthand","webpack://ls/./src/helpers.ts","webpack://ls/./src/ls.ts"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","NOOP","args","isObject","item","constructor","name","hasLS","supportsLS","undefined","localStorage","flush","APX","String","fromCharCode","obfus","str","encrypt","JSON","stringify","map","x","charCodeAt","join","parse","config","ttl","encrypter","decrypter","secret","force","keys","forEach","getItem","Date","now","removeItem","set","value","localConfig","_conf","hasTTL","isNaN","val","setItem","decrypt","clear","remove"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAY,GAAID,IAEhBD,EAAS,GAAIC,IARf,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCA3E,MAAMI,EAAO,IAAIC,OAIXC,EAAYC,GACP,OAATA,GAA2C,WAA1BA,EAAKC,YAAYC,KCK3C,IAAIC,EAEJ,MAAMC,EAAa,KACjB,QAAcC,IAAVF,EAAqB,OAAOA,EAChCA,GAAQ,EAER,IACOG,eACHH,GAAQ,GAEV,MAGAA,GAAQ,EAMV,OAFAI,IAEOJ,GAIHK,EAAMC,OAAOC,aAAa,GAG1BC,EAA+B,CAACC,EAAK1B,EAAK2B,GAAU,IACxDA,EACI,IAAMC,KAAKC,UAAUH,IACpBI,KAAKC,GAAMR,OAAOC,aAAaO,EAAEC,WAAW,GAAMhC,KAClDiC,KAAK,IACNL,KAAKM,MAAM,IAAKR,GAAkBI,KAAKC,GAAMR,OAAOC,aAAaO,EAAEC,WAAW,GAAMhC,KAAiBiC,KAAK,KAM1GE,EAA6B,CACjCC,IAAK,KACLT,SAAS,EACTU,UAAWZ,EACXa,UAR2B,CAACZ,EAAK1B,IAC1ByB,EAAMC,EAAK1B,GAAK,GAQvBuC,OAAQ,IAiFJlB,EAAQ,CAACmB,GAAQ,KACrB,IAAKtB,IAAc,OAAO,EAC1BhB,OAAOuC,KAAKrB,cAAcsB,SAAS1C,IACjC,MAAM0B,EAAMN,aAAauB,QAAQ3C,GACjC,IAAK0B,EAAK,OACV,IAAIZ,EACJ,IACEA,EAAOc,KAAKM,MAAMR,GAClB,MAEA,OAGEb,EAASC,IAASQ,KAAOR,IAAS8B,KAAKC,MAAQ/B,EAAKsB,KAAOI,IAC7DpB,aAAa0B,WAAW9C,OAe9B,GACEmC,SACAY,IA7GU,CAAc/C,EAAagD,EAAUC,EAAkC,MACjF,IAAK/B,IAAc,OAAO,EAE1B,MAAMgC,EAAQ,IACTf,KACAc,EACHtB,SAAiC,IAAxBsB,EAAYtB,UAA4BsB,EAAYtB,SAAWQ,EAAOR,SAC/ES,IAAyB,OAApBa,EAAYb,IAAe,KAAOa,EAAYb,KAAOD,EAAOC,KAGnE,IACE,MAAMe,EAASD,EAAMd,MAAQgB,MAAMF,EAAMd,MAAQc,EAAMd,IAAM,EAC7D,IAAIiB,EAAMF,EAAS,CAAE,CAAC7B,GAAM0B,EAAOZ,IAAKQ,KAAKC,MAAgC,IAAvBK,EAAMd,KAAyBY,EAEjFE,EAAMvB,UAEJwB,EACDE,EAAgC/B,IAAQ4B,EAAMb,WAAa1B,GACzD0C,EAAgC/B,GACjC4B,EAAMX,QAGRc,GAAOH,EAAMb,WAAa1B,GAAM0C,EAAKH,EAAMX,SAI/CnB,aAAakC,QAAQtD,EAAK4B,KAAKC,UAAUwB,IACzC,MAEA,OAAO,IAiFThD,IA7EU,CAAcL,EAAaiD,EAAkC,MACvE,IAAK/B,IAAc,OAAO,KAE1B,MAAMQ,EAAMN,aAAauB,QAAQ3C,GAEjC,IAAK0B,EACH,OAAO,KAGT,MAAMwB,EAAQ,IACTf,KACAc,EACHtB,SAAiC,IAAxBsB,EAAYtB,UAA4BsB,EAAYtB,SAAWQ,EAAOR,SAC/ES,IAAyB,OAApBa,EAAYb,IAAe,KAAOa,EAAYb,KAAOD,EAAOC,KAGnE,IAAItB,EAAOc,KAAKM,MAAMR,GACtB,MAAMyB,EAAStC,EAASC,IAASQ,KAAOR,EAExC,GAAIoC,EAAMK,SAAWL,EAAMvB,QACzB,IACMwB,EACFrC,EAAKQ,IAAQ4B,EAAMZ,WAAa3B,GAAMG,EAAKQ,GAAM4B,EAAMX,QAEvDzB,GAAQoC,EAAMZ,WAAa3B,GAAMG,EAAMoC,EAAMX,QAE/C,OAOJ,OAAKY,EAIDP,KAAKC,MAAQ/B,EAAKsB,KACpBhB,aAAa0B,WAAW9C,GACjB,MAGFc,EAAKQ,GARHR,GA4CTO,QACAmC,MAVY,KACZ,IAAKtC,IAAc,OAAO,EAC1BE,aAAaoC,SASbC,OAhBczD,IACd,IAAKkB,IAAc,OAAO,EAC1BE,aAAa0B,WAAW9C,K","file":"localstorage-slim.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ls\"] = factory();\n\telse\n\t\troot[\"ls\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const NOOP = (...args: unknown[]): unknown => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: any): boolean => {\n  return item !== null && item.constructor.name === 'Object';\n};\n","/*\n * https://github.com/niketpathak/localstorage-slim\n * Copyright (c) 2021 Niket Pathak\n * MIT License\n */\n\nimport { isObject, NOOP } from './helpers';\nimport type { Encrypter, Decrypter, LocalStorageConfig } from './types';\n\n// private flags\nlet hasLS: boolean;\n\nconst supportsLS = (): boolean => {\n  if (hasLS !== undefined) return hasLS;\n  hasLS = true;\n\n  try {\n    if (!localStorage) {\n      hasLS = false;\n    }\n  } catch {\n    // some browsers throw an error if you try to access local storage (e.g. brave browser)\n    // and some like Safari do not allow access to LS in incognito mode\n    hasLS = false;\n  }\n\n  // flush once on init\n  flush();\n\n  return hasLS;\n};\n\n// Apex\nconst APX = String.fromCharCode(0);\n\n// tiny obsfuscator\nconst obfus: Encrypter | Decrypter = (str, key, encrypt = true) =>\n  encrypt\n    ? [...((JSON.stringify(str) as unknown) as string[])]\n      .map((x) => String.fromCharCode(x.charCodeAt(0) + (key as number)))\n      .join('')\n    : JSON.parse([...(str as string[])].map((x) => String.fromCharCode(x.charCodeAt(0) - (key as number))).join(''));\n\nconst decrypter: Decrypter = (str, key) => {\n  return obfus(str, key, false);\n};\n\nconst config: LocalStorageConfig = {\n  ttl: null,\n  encrypt: false,\n  encrypter: obfus,\n  decrypter,\n  secret: 75,\n};\n\nconst set = <T = unknown>(key: string, value: T, localConfig: LocalStorageConfig = {}): void | boolean => {\n  if (!supportsLS()) return false;\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  try {\n    const hasTTL = _conf.ttl && !isNaN(_conf.ttl) && _conf.ttl > 0;\n    let val = hasTTL ? { [APX]: value, ttl: Date.now() + (_conf.ttl as number) * 1e3 } : value;\n\n    if (_conf.encrypt) {\n      // if ttl exists, only encrypt the value\n      if (hasTTL) {\n        (val as Record<string, unknown>)[APX] = (_conf.encrypter || NOOP)(\n          (val as Record<string, unknown>)[APX],\n          _conf.secret\n        ) as string;\n      } else {\n        val = (_conf.encrypter || NOOP)(val, _conf.secret) as T;\n      }\n    }\n\n    localStorage.setItem(key, JSON.stringify(val));\n  } catch {\n    // Sometimes stringify fails due to circular refs\n    return false;\n  }\n};\n\nconst get = <T = unknown>(key: string, localConfig: LocalStorageConfig = {}): T | null => {\n  if (!supportsLS()) return null;\n\n  const str = localStorage.getItem(key);\n\n  if (!str) {\n    return null;\n  }\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  let item = JSON.parse(str);\n  const hasTTL = isObject(item) && APX in item;\n\n  if (_conf.decrypt || _conf.encrypt) {\n    try {\n      if (hasTTL) {\n        item[APX] = (_conf.decrypter || NOOP)(item[APX], _conf.secret) as string;\n      } else {\n        item = (_conf.decrypter || NOOP)(item, _conf.secret) as string;\n      }\n    } catch {\n      // Either the secret is incorrect or there was a parsing error\n      // do nothing [i.e. return the encrypted/unparsed value]\n    }\n  }\n\n  // if not using ttl, return immediately\n  if (!hasTTL) {\n    return item;\n  }\n\n  if (Date.now() > item.ttl) {\n    localStorage.removeItem(key);\n    return null;\n  }\n\n  return item[APX];\n};\n\nconst flush = (force = false): false | void => {\n  if (!supportsLS()) return false;\n  Object.keys(localStorage).forEach((key) => {\n    const str = localStorage.getItem(key);\n    if (!str) return; // continue iteration\n    let item;\n    try {\n      item = JSON.parse(str);\n    } catch {\n      // Some packages write strings to localStorage that are not converted by JSON.stringify(), so we need to ignore it\n      return;\n    }\n    // flush only if ttl was set and is/is not expired\n    if (isObject(item) && APX in item && (Date.now() > item.ttl || force)) {\n      localStorage.removeItem(key);\n    }\n  });\n};\n\nconst remove = (key: string): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.removeItem(key);\n};\n\nconst clear = (): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.clear();\n};\n\nexport default {\n  config,\n  set,\n  get,\n  flush,\n  clear,\n  remove,\n};\n"],"sourceRoot":""}