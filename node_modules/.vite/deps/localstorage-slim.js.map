{
  "version": 3,
  "sources": ["../../localstorage-slim/dist/webpack:/ls/webpack/universalModuleDefinition", "../../localstorage-slim/dist/webpack:/ls/webpack/bootstrap", "../../localstorage-slim/dist/webpack:/ls/webpack/runtime/define property getters", "../../localstorage-slim/dist/webpack:/ls/webpack/runtime/hasOwnProperty shorthand", "../../localstorage-slim/dist/webpack:/ls/src/helpers.ts", "../../localstorage-slim/dist/webpack:/ls/src/ls.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ls\"] = factory();\n\telse\n\t\troot[\"ls\"] = factory();\n})(this, function() {\nreturn ", "// The require scope\nvar __webpack_require__ = {};\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "export const NOOP = (...args: unknown[]): unknown => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: any): boolean => {\n  return item !== null && item.constructor.name === 'Object';\n};\n", "/*\n * https://github.com/niketpathak/localstorage-slim\n * Copyright (c) 2021 Niket Pathak\n * MIT License\n */\n\nimport { isObject, NOOP } from './helpers';\nimport type { Encrypter, Decrypter, LocalStorageConfig } from './types';\n\n// private flags\nlet hasLS: boolean;\n\nconst supportsLS = (): boolean => {\n  if (hasLS !== undefined) return hasLS;\n  hasLS = true;\n\n  try {\n    if (!localStorage) {\n      hasLS = false;\n    }\n  } catch {\n    // some browsers throw an error if you try to access local storage (e.g. brave browser)\n    // and some like Safari do not allow access to LS in incognito mode\n    hasLS = false;\n  }\n\n  // flush once on init\n  flush();\n\n  return hasLS;\n};\n\n// Apex\nconst APX = String.fromCharCode(0);\n\n// tiny obsfuscator\nconst obfus: Encrypter | Decrypter = (str, key, encrypt = true) =>\n  encrypt\n    ? [...((JSON.stringify(str) as unknown) as string[])]\n      .map((x) => String.fromCharCode(x.charCodeAt(0) + (key as number)))\n      .join('')\n    : JSON.parse([...(str as string[])].map((x) => String.fromCharCode(x.charCodeAt(0) - (key as number))).join(''));\n\nconst decrypter: Decrypter = (str, key) => {\n  return obfus(str, key, false);\n};\n\nconst config: LocalStorageConfig = {\n  ttl: null,\n  encrypt: false,\n  encrypter: obfus,\n  decrypter,\n  secret: 75,\n};\n\nconst set = <T = unknown>(key: string, value: T, localConfig: LocalStorageConfig = {}): void | boolean => {\n  if (!supportsLS()) return false;\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  try {\n    const hasTTL = _conf.ttl && !isNaN(_conf.ttl) && _conf.ttl > 0;\n    let val = hasTTL ? { [APX]: value, ttl: Date.now() + (_conf.ttl as number) * 1e3 } : value;\n\n    if (_conf.encrypt) {\n      // if ttl exists, only encrypt the value\n      if (hasTTL) {\n        (val as Record<string, unknown>)[APX] = (_conf.encrypter || NOOP)(\n          (val as Record<string, unknown>)[APX],\n          _conf.secret\n        ) as string;\n      } else {\n        val = (_conf.encrypter || NOOP)(val, _conf.secret) as T;\n      }\n    }\n\n    localStorage.setItem(key, JSON.stringify(val));\n  } catch {\n    // Sometimes stringify fails due to circular refs\n    return false;\n  }\n};\n\nconst get = <T = unknown>(key: string, localConfig: LocalStorageConfig = {}): T | null => {\n  if (!supportsLS()) return null;\n\n  const str = localStorage.getItem(key);\n\n  if (!str) {\n    return null;\n  }\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  let item = JSON.parse(str);\n  const hasTTL = isObject(item) && APX in item;\n\n  if (_conf.decrypt || _conf.encrypt) {\n    try {\n      if (hasTTL) {\n        item[APX] = (_conf.decrypter || NOOP)(item[APX], _conf.secret) as string;\n      } else {\n        item = (_conf.decrypter || NOOP)(item, _conf.secret) as string;\n      }\n    } catch {\n      // Either the secret is incorrect or there was a parsing error\n      // do nothing [i.e. return the encrypted/unparsed value]\n    }\n  }\n\n  // if not using ttl, return immediately\n  if (!hasTTL) {\n    return item;\n  }\n\n  if (Date.now() > item.ttl) {\n    localStorage.removeItem(key);\n    return null;\n  }\n\n  return item[APX];\n};\n\nconst flush = (force = false): false | void => {\n  if (!supportsLS()) return false;\n  Object.keys(localStorage).forEach((key) => {\n    const str = localStorage.getItem(key);\n    if (!str) return; // continue iteration\n    let item;\n    try {\n      item = JSON.parse(str);\n    } catch {\n      // Some packages write strings to localStorage that are not converted by JSON.stringify(), so we need to ignore it\n      return;\n    }\n    // flush only if ttl was set and is/is not expired\n    if (isObject(item) && APX in item && (Date.now() > item.ttl || force)) {\n      localStorage.removeItem(key);\n    }\n  });\n};\n\nconst remove = (key: string): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.removeItem(key);\n};\n\nconst clear = (): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.clear();\n};\n\nexport default {\n  config,\n  set,\n  get,\n  flush,\n  clear,\n  remove,\n};\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "this", "__webpack_require__", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "NOOP", "args", "isObject", "item", "constructor", "name", "hasLS", "supportsLS", "localStorage", "flush", "APX", "String", "fromCharCode", "obfus", "str", "encrypt", "JSON", "stringify", "map", "x", "charCodeAt", "join", "parse", "config", "ttl", "encrypter", "decrypter", "secret", "force", "keys", "forEach", "getItem", "Date", "now", "removeItem", "set", "value", "localConfig", "_conf", "hasTTL", "isNaN", "val", "setItem", "decrypt", "clear", "remove"]
}
